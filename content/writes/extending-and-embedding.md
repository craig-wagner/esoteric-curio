---
title: "Extending and Embedding"
date: 2009-10-07 02:21:48
type: post
categories:
- Damaged Bits
tags:
- lua
---

<p>If you&#8217;re like me, you&#8217;ve read a handful of really useful articles about extending and embedding things like perl, Python, Java, lisp, scheme or lua.  The slant there is a technical one: &#8220;So you need Java, here&#8217;s how to embed it.&#8221;  I&#8217;ve embedded Python once, perl and Java countless times and, most recently, lua.  Throughout this I realized that I don&#8217;t need the languages as much as I need a convenient extension out of C.  In other words, if your foundation app is feature-rich, embedding isn't as much about adding the features of a specific language as it is about exposing the features of your system.</p>  <p>Given this context, there is a lack of articles about how to choose the appropriate embedding technology for a given project.  Each language has its own advantages and people religiously argue about them seemingly to no end.  Things get interesting when you look to embedding languages, as their internal implementation decisions start to influence what is and isn't possible.  I&#8217;ll take you on a brief whirlwind tour of my personal experience embedding.</p>  <h3>Perl</h3>  <p>Many of you know I program in Perl quite often.  Many people hate Perl and believe it to be an abomination.  I love Perl for its flexibility, expressiveness and its terseness &#8212; aligning it with myself.  However, the perl (5.10 and earlier) interpreter is a horrid, catastrophic example of how not to write a virtual machine for an interpreted language; spaghetti does not begin to describe that mess that is perl internals.  The API is insufficiently documented, the internal data representations are indecently exposed and the the way thread support was backed into the code (like a garbage truck through a toy shop) make it more than a challenge to embed.  Now, I&#8217;ve been writing XS code for years (the C-like language for extending perl itself) and I know and love the language itself, but I&#8217;d argue that it is rarely a good idea to embed perl in any application.</p>  <p>You may have noted that I claimed to have embedded perl several times in applications.  Some of those turned out to be a good idea.  Both (yes only two) of those times, the reason it ended up being a good idea was that to make my application more useful I needed the wealth of CPAN (the comprehensive Perl archive network that contains a wealth of easy-to-use Perl wrappers around common needs).  While in the end I won, embedding perl was an awful experience and I wouldn't recommend it to anyone.  My specific problems came down to debugging memory usage as it transcends from C into Perl heap and the painful problem that is threading within perl.  Each time, integrating into perl&#8217;s threading system proved a waste of time and I ended up starting an interpreter for each thread (or had a resource pool of interpreters from which each thread would reserve).  So many useful CPAN modules aren&#8217;t thread-safe and were never developed with a mindset that they would be loaded into a perl that might be embedded in another system.</p>  <p>While I love the language, I hate the implementation.</p>  <h3>Python</h3>  <p>While I like Python as a language, I personally find that if my job doesn&#8217;t fit in perl and that Python would be a better choice, I usually think a bit harder and realize that C would be even better.  I realize this isn&#8217;t the same mental leap made by most people, but I love C.  C is my favorite language.  In fact, I wouldn&#8217;t be writing this article if I didn&#8217;t write so many applications in C that can benefit from an embedded interpreter to ease configuration and processing tasks.</p>  <p>In fact, I would argue that Python is a great language to embed because the of the interpreter.  It's implementation is cleaner than perl&#8217;s &#8212; as I&#8217;ve mentioned the bar could not be set much lower.  The fact is that embedding Python in a complicated multi-threaded and/or even driven application really shows the inadequacies of its embedding design.  That combined with the fact that I&#8217;d rather be coding directly in C means: "I wouldn&#8217;t embed that again."</p>  <p>Now, all the applications in which I typically embed interpreters or virtual machines are complicated.  If your application is single-threaded and doesn&#8217;t do extensive co-routines (e.g. closure-oriented programming or event driven systems) then Python could really be an ideal embedding language.</p>  <h3>Java</h3>  <p>Java is a complicated discussion.  I have a lot of mixed feelings about Java.  No language should have functions in its core distribution deprecated at the rate that Java boasts &#8212; it&#8217;s dysfunctional.  Java as a language itself is quite nice.  It is powerful, fast, and expressive.  It has some annoyances like its verboseness and sprawling code bases.  It has one true, deep negative: Java programmers.  Now, not all Java programmers are bad, but I've seen far too much Java code produced by programmers far and wide that is of a quality that is flat-out unacceptably low.</p>  <p>When you&#8217;re embedding a language, some of those negatives don&#8217;t matter so much.  We can instead concentrate on ease of embedding.  Java has to be, hands-down, the easiest system to embed.  The API is crystal clear and absolutely complete.  It is all held in a single, small header file called jni.h.  Every time I&#8217;ve embedded Java is has been simple and painless.  JNI team, pat yourself on the back &#8212; I&#8217;ll happily buy a round of beers if we ever run into each other.</p>  <p>On top of the ease of embedding, the native support for mapping application (C) threads into JVM threads is concise and demonstrates pre-meditated good engineering.</p>  <p>One reason I don&#8217;t like Java for this is that it isn&#8217;t really &#8220;interpreted.&#8221;  I have to compile (or auto-compile) my code to get it to run in my app.  Now, perhaps I could use Java to pull in something like Jython or JRuby to make a rather obtuse, but convenient, system.  Success via indirection has never been high on my list &#8212; if I ever try it, I&#8217;ll be sure to let you know how it went.</p>  <h3>Tcl, lisp, ruby, PHP</h3>  <p>Too old, too arcane, AYFKM, leave it on the web guys, respectively.</p>  <p>Okay, in all fairness, I didn&#8217;t give Tcl its due.  It&#8217;s likely the most widely embedded language.  I just don&#8217;t like Tcl and it shows.</p>  <h3>Javascript</h3>  <p>Javascript deserves its own section for arguments against embedding a language.  If you have a single-threaded program that is not event driven, Javascript is a brilliant choice.  I don&#8217;t remember the last time I wrote an application that was both that simple and was in need of an embedded language.  So, the fact that Javascript has no support for threading makes it utterly painful and obtuse to embed in most systems.  This saddens me.  Of all the languages I program in, Javascript is likely my favorite.  I know this must be on the merits of the syntax and expressiveness of the language because I loathe DOM and anything that touches it.  Oh! how I wish Javascript embraced threading.  Oh! how I wish Javascript had the embeddability of Lua.</p>  <h3>Lua</h3>  <p><a href="https://www.lua.org/">Lua</a> is my new love.  It is the reason I decided to write this article.  I actually don&#8217;t like the lua language.  I don&#8217;t particularly like the internal implementation (garbage collected instead of ref counted).  It doesn&#8217;t have particularly useful extensions to add feature value to your system.  So, what is it about lua?</p>  <p>I&#8127;ve been working a lot on a system called <a href="https://labs.omniti.com/trac/reconnoiter">Reconnoiter</a>.  noitd, the agent responsible for performing active checks against other systems, has a high-performance hybrid thread/event core.  Writing code for a hybrid thread/event system can be quite mind bending to write and challenging to debug.  Reconnoiter allows writing checks as modules that are dynamically loaded into the system at run-time.  The hybrid thread/event core means that the core itself is capable of handing hundreds of thousands of open sockets (think network connections).  Writing complex event-driven C code severely limits the audience that can contribute check code to this open source project.  This frames the need.</p>  <p>Managing hundreds of thousands of concurrent threads in the system is a recipe for suboptimal performance.  In order to remove the complexity of event-driven programming, I need to extend Reconnoiter&#8217;s core to a language that could provide the feel of a procedural (or OO) programming atmosphere while maintaining a non-blocking, continuation based implementation for high single-system concurrency.</p>  <p>Now, this is possible (sort of) with many of the embedding choices. When I get to a point in the interpreted code where I need to suspend what I&#8217;m doing and complete it later when actionable data is available (say date from a network read)  to take some action.  The issue is that in order to resume all these languages where they left off, I need to maintain their C stacks.  This can be accomplished with a user-space threading implementation strategy using setjmp, longjmp and a healthy sprinkling of black magic.  In a lot of ways, this approach doesn&#8217;t solve the problem if requiring a interpreter or VM thread for each concurrent operation which would voraciously consume resources.</p>  <p>Enter lua, champion of concurrency.  lua is a stack based virtual machine specifically designed for integration with larger C systems.  Within lua, assuming you don&#8217;t use any third-party extensions (of which there are few), I can leverage the <a href="https://www.lua.org/manual/5.1/manual.html#lua_yield">lua_yield</a> and <a href="https://www.lua.org/manual/5.1/manual.html#lua_resume">lua_resume</a> API calls to suspend the execution of a lua co-routine (lua-space thread) without the need of capturing a C stack.  The state of lua&#8217;s execution is represented in the lua stack and simply pick up later right were I left off.  This is a technical nuance, but one that provides a considerable amount of freedom.  In a single thread, I can open 100k network sockets and have them all independently driven by lua programs without maintaining 100k C stacks.  Furthermore, the lua programs give the feel of blocking reads and writes making network programming once again bearable.</p>  <p>After wrapping Reconnoiter&#8217;s <a href="https://labs.omniti.com/trac/reconnoiter/browser/trunk/src/eventer">libeventer</a> and check systems with lua, I was able to replace the previous incarnations of our HTTP checker (based on libserf, then on libcurl) with a 170 line lua <a href="https://labs.omniti.com/trac/reconnoiter/browser/trunk/src/modules-lua/noit/HttpClient.lua">HttpClient</a> that consumes less memory and less CPU!   If you&#8217;re wondering, yes, the client supports chunked transfer encoding, gzip/deflate content encoding, arbitrary headers, client payloads and methods.</p>  <p>So, despite not really liking lua as a language (I find its syntax a bit painful), the simplicity of embedding it my application was on par with Java, the fact that it is truly interpreted (no compiling lua before it will run) and the absolutely brilliant exposure of its continuations as first-class embedding APIs puts me in bed with lua.</p>  <h3>Summation</h3>  <p>Never embed a language just to embed a language; always have a purpose in mind.  Understand the host architecture in which you need to embed and attempt to match the strong points of a particular interpreter or VM to your needs.  For example, if you have a heavily threaded host architecture, don&#8217;t embed something that doesn&#8217;t support threading well (or claims to but takes global locks).</p>  <p>Next time I embed, I will start with three preferences: Java, Javascript and Lua.  Sadly, I predict Javascript will be disqualified quickly due to its deficiencies.  Java and Lua both have that pros and cons.  I just hope the next project finds Lua the best bedmate, I&#8217;m already looking forward to working with it again.</p>
