title: Asynchronous PostgreSQL Candy
date: 2009-12-27 18:49:32
---

<p>I've put the first (intended) use of the <a href="http://labs.omniti.com/trac/pgsoltools/browser/trunk/contrib/pg_amqp">pg_amqp</a> setup to the test.  So far I'm very pleased.  While none of the code for the usage is open source the real "magic sauce" is open and has had a few bug fixes and bits of robustness added since I last posted. I can, however, describe the use and let your imagination run while.</p>  <p>The parts: <a href="http://www.postgresql.org/">PostgreSQL</a>, <a href="http://www.rabbitmq.com/">RabbitMQ</a>, and a bit of Java around <a href="http://lucene.apache.org">Lucene</a>.  Our java program actually uses <a href="http://www.mortbay.org/jetty/">jetty</a> to expose a tiny servlet that accepts search queries and returns json results making AJAX-style searches easy and fast.</p>  <p>The obvious question we all face in these sort of configurations is "how do keep our search indexes up-to-date?"  Usually, we relax constraints (wisely so) and determine exactly "how up-to-date does out index needs to be."  If you can answer this question with a number sufficiently far from zero, you've won.  In our situation, the user experience must be able to search and find the updated items in database via search immediately after insert or update (within a 100ms or so).</p>  <p>Enter message queueing.  The first thing we do is make our Java process connect to RabbitMQ, bind a queue and consume.  The messages it consumes from the queue have instructions on the precise element that has changed which then causes an query against the database retrieving all the new data to be reindexed (in our case, it is much more than can be easily witnessed from a trigger on update) and updates the Lucene indexes.</p>  <p>The second updated we made is to PostgreSQL by installing pg_amqp.  On the tables whose changes should induce reindexing, we add a (or augment the existing) trigger to call: amqp.publish('amq.direct', 'searchstuff', E'reindex\\t' || NEW.rowid).  Assuming we have a column called rowid, this will queue a message that looks like "reindex&lt;tab&gt;328432"</p>  <p>The neat part is that if the update is rolled back in the database, the message is never sent.  Otherwise, we see the message from the our indexing and search app and viola.</p>  <p>I think this technique is really useful for people that are currently leveraging Lucene-based systems to provide powerful search functionality yet keep their data safe and secure in PostgreSQL.</p>
